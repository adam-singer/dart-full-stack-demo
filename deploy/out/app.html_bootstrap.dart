import "dart:html" as q;import "dart:collection" as LB;class sB{static const  tB="Chrome";static const  uB="Safari";final  lB;final  minimumVersion;const sB(this.lB,[this.minimumVersion]);}class vB{final  name;const vB(this.name);}var SB='hello from dart';TB(){} UB(){var HC=q.document.body;var IC;var JC=new yB(HC);IC=HC.nodes[1];var KC=JC.mB(()=>SB,false);IC.nodes.add(KC);JC.JB();JC.insert();}main(){PB=false;TB();UB();}typedef  n( e);typedef  VB( changes);typedef  s();typedef  WB();class AB{final oldValue;final newValue;final  changes;AB(this.oldValue,this.newValue,[this.changes]); operator==(g){return g is AB&&oldValue==g.oldValue&&newValue==g.newValue&&changes==g.changes;} get hashCode=>dB(oldValue,newValue,changes); toString(){if(changes!=null)return '#<ChangeNotification to ${newValue}: ${changes}>';return '#<ChangeNotification from ${oldValue} to ${newValue}>';}}class MB{MB();} XB(g, i,[ debugName]){if(g is o){var h=g;return BB(h,(p){i(new AB(h,h,p));});}var j=new DB(g,i,debugName);if(!j.LC()){return YB;}return j.MC;} BB( g, i){if(g.RB==null)g.RB=new EB();var h=g.RB.add(i);return h.remove;}class o{} YB(){}var v;var CB;class DB{static var ZB=0;final  NC= ++DB.ZB;final  OC;final  PC;final  QC;final  RC=new Map();final  SC=[] ;var TC=false;var UC;DB(this.OC,this.PC,this.QC); toString()=>QC!=null?'<observer ${NC}: ${QC}>':'<observer ${NC}>'; LC(){var h=v;v=this;try {UC=OC();if(UC is Iterable&&UC is !List&&UC is !o){UC=(UC as Iterable).toList();}}catch (g,i){NB(g,i,OC,'from ${this}');UC=null;}RC.forEach(VC);RC.clear();assert(v==this);v=h;WC();return SC.length>0;} XC( i){try {PC(i);}catch (g,h){NB(g,h,PC,'from ${this}');}} WC(){var g=UC;if(g is !o)return;SC.add(BB(g,(h){XC(new AB(g,g,h));}));} VC( i, j){SC.add(BB(i,(p){if(TC)return;for(var g in p){var h=j[g.key];if(h!=null&&(h&g.type)!=0){TC=true;if(CB==null){CB=new LB.SplayTreeMap();}CB[NC]=this;return;}}}));} MC(){for(var g in SC){g();}TC=false;}}typedef  aB(error,stackTrace,obj, message);var NB=bB; bB(i,g,h, j){print('web_ui.observe: unhandled error calling ${h} ${j}.\n' 'error:\n${i}\n\nstack trace:\n${g}');}class cB{cB();}class m<l>{var YC;var ZC;var aC;var bC;m.FC( g,this.aC):bC=g{if(aC!=null)aC.cC++ ;} get next=>ZC; get value=>bC;set value( g)=>bC=g; dC( g, h){ZC=h;YC=g;if(g!=null)g.ZC=this;if(h!=null)h.YC=this;return this;} append( g)=>new m<l>.FC(g,aC).dC(this,ZC); remove(){if(aC==null)return;aC.cC-- ;if(YC!=null){YC.ZC=ZC;}else{aC.eC=ZC;}if(ZC!=null){ZC.YC=YC;}else{aC.fC=YC;}ZC=null;YC=null;aC=null;}}class EB<l> extends LB.IterableBase<l>{var eC;var fC; get length=>cC;var cC=0;EB(){} get head=>eC; add( h){var g=new m<l>.FC(h,this);if(fC==null)return eC=fC=g;return fC=g.dC(fC,null);} addAll( g)=>g.forEach(add); get iterator=>new wB<l>(this);}class wB<l> implements Iterator<l>{var gC;var aC;var hC;var iC=-1;wB(this.aC){gC=new List<m>(aC.length);var h=0;var g=aC.head;while (g!=null){gC[h++ ]=g;g=g.next;}} get current=>hC; moveNext(){do{iC++ ;}while(iC<gC.length&&gC[iC].aC!=aC);if(iC<gC.length){hC=gC[iC].value;return true;}else{hC=null;return false;}}}OB(h,g)=>h.hashCode*31+g.hashCode;dB(h,g,i)=>OB(OB(h,g),i); eB(h, g,[ stringValue]){var i=h is cB;if(stringValue==null){stringValue=h.toString();}if(!i&&g is q.Text){g.text=stringValue;}else{var j=g;g=i?new q.Element.html(stringValue):new q.Text(stringValue);j.replaceWith(g);}return g;}abstract class FB{ JB(){} insert(); remove();}class xB extends FB{final exp;final  action;final  isFinal;var w;xB(this.exp,this.action,this.isFinal); insert(){if(isFinal){action(new AB(null,exp()));}else if(w!=null){throw new StateError('binding already attached');}else{w=hB(exp,action,'generic-binding');}} remove(){if(!isFinal){w();w=null;}}}class yB extends FB{final  nB;final  children=[] ;final  nodes=[] ;yB(this.nB); mB( h,i){var g=new q.Text('');children.add(new xB(()=>'${h()}',(j){g=eB(h(),g,j.newValue);},i));return g;} add( g)=>nodes.add(g); addAll( g)=>nodes.addAll(g); JB(){for(var g=0,h=children.length;g<h;g++ ){children[g].JB();}} insert(){for(var g=0,h=children.length;g<h;g++ ){children[g].insert();}} remove(){for(var g=children.length-1;g>=0;g-- ){children[g].remove();}children.clear();}}var PB=false; fB(g, p,[ debugName]){if(PB)return XB(g,p);if(p==null)return (){};if(GB==null)GB=new EB<t>();var i;var h=k.kB;if(g is QB){i=(g as QB).jC;}else if(g is Function){i=g;try {var j=g();if(j is List){h=k.u;}else if(j is Iterable){h=k.u;i=()=>g().toList();}else if((j is LB.LinkedHashMap)||(j is LB.SplayTreeMap)){h=k.IB;}else if(j is Map){h=k.HB;}}catch (oB,pB){print('error: evaluating ${debugName!=null?debugName:"<unnamed>"} ' 'watcher threw error (${oB}, ${pB})');}}else if(g is List){i=()=>g;h=k.u;}else if(g is Iterable){i=()=>g.toList();h=k.u;}else if((g is LB.LinkedHashMap)||(g is LB.SplayTreeMap)){i=()=>g;h=k.IB;}else if(g is Map){i=()=>g;h=k.HB;}var qB=gB(h,i,p,debugName);var rB=GB.add(qB);return rB.remove;} gB( j, g, i, h){switch (j){case k.u:return new zB(g,i,h);case k.IB:return new DC(g,i,h);case k.HB:return new AC(g,i,h);default:return new t(g,i,h);}} hB(h,i,[debugName]){var j=fB(h,i,debugName);var g=h;if(g is Function){g=g();}if(g is Iterable&&g is !List){g=g.toList();}i(new AB(null,g));return j;}var GB;class t{final  KB;final  jC;final  kC;var lC;t(this.jC,this.kC,this.KB){lC=jC();} toString()=>KB==null?'<unnamed>':KB; mC(g){lC=g;}nC(){try {return jC();}catch (g,h){print('error: evaluating ${this} watcher threw an exception (${g}, ${h})');}return lC;}}typedef  iB<jB>();class QB<jB>{QB();}class zB<jB> extends t{zB(g, i, h):super(g,i,h){mC(nC());} mC(g){lC=new List<jB>.from(g);}}class AC<BC,CC> extends t{AC(g, i, h):super(g,i,h){mC(nC());} mC(g){lC=new Map<BC,CC>.from(g);}}class DC<BC,CC> extends t{DC(g, i, h):super(g,i,h){mC(nC());} mC(g){lC=new LB.LinkedHashMap.from(g);}}class k{final oC;const k.GC(this.oC);toString()=>'Enum.${oC}';static const u=const k.GC('LIST');static const HB=const k.GC('HASH_MAP');static const IB=const k.GC('ORDERED_MAP');static const kB=const k.GC('OTHER');}